정렬 : 데이터를 특정한 기준에 따라서 순서대로 나열하는 것(오름차순/내림차순)
데이터 정렬 -> 이진 탐색
선택 정렬 / 삽입 정렬 / 퀵 정렬 / 계수 정렬
오름차순과 내림차순은 크기 비교만 반대
(내림차순 = 오름차순 결과의 뒤집기)

<선택 정렬>
가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고,
그 다음 작은 데이터를 선태해 앞에서 두번째 데이터와 바꾸는 과정을 반복
정렬을 시킨 데이터는 정렬의 범위에서 제거
->범위의 크기를 1씩 줄여가면서 계속해서 범위 안의 값 중 최솟값을 찾는 과정을 반복

시간복잡도 : 연산 횟수 : N+(N-1)+(N-2)+...+2
대략 N*(N-1)/2 ~ 빅오 표기법 O(N^2)  
소스코드 상 간단한 형태의 2중 반복문 사용
->데이터의 개수가 늘어남에 따라 속도 급격히 저하

<삽입 정렬>
데이터를 하나씩 확인해가며, 각각의 데이터를 적절한 위치에 삽입하기
기존의 데이터가 정렬이 되어있을 때 훨씬 효율적이다.
삽입정렬은 두번째 데이터부터 시작.(첫 번째 데이터는 그 자체로 정렬되어 있다고 판단)
정렬이 이루어진 원소는 항상 오름차순(혹은 내림차순)을 유지하고 있음
삽입될 데이터보다 작은 데이터를 만나면 해당 위치에서 멈추면 됨.

시간 복잡도 : O(N)~O(N^2)

<퀵 정렬>
기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꿈
& 리스트를 반으로 나누는 방식으로 동작
피벗 : 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준
호어 분할 방식 : 리스트에서 첫 번째 데이터를 피벗으로 정함.
피벗 설정 후 
왼쪽에서부터  피벗보다 큰 데이터를, 오른쪽에서부터는 피벗보다 작은 데이터를 찾음
큰 데이터와 작은 데이터의 위츠를  서로 교환
중간 지점에서 엇갈리는 경우 작은 데이터와 피벗의 위치를 서로 바꿈
위 과정이 끝나면 피벗을 기준으로 왼쪽은 작은데이터, 오른쪽은 큰 데이터로 분할(or파티션)이 완료된다.
피벗 기준 왼쪽 오른 쪽에 대해서 다시 퀵정렬을 실행.
-> 재귀함수와 동작원리가 같다. => 종료 조건 또한 필요함.

시간복잡도 : 평균적으로 O(NlogN) : 선택, 삽입에 비해 매우 빠른편
	최악의 경우 O(N^2) : 이미 데이터가 어느정도 정렬이 되어있는 경우
+데이터의 특성을 파악하기 힘든 경우에 이용하기 좋다.

<계수 정렬>
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
시간복잡도 : 데이터가 N개, 최댓값이 K, 최악의 경우에도 수행시간O(N+K)를 보장함
but 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있음
일반적으로 Max - min 의 값이 100만을 넘기지 않을 때 효과적임
?? ~ 계수 정렬을 이용하기 위해서는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야 하기 때문
결과적으로 리스트에는 각각의 데이터가 몇번 등장했는지에 대한 횟수가 기록된다.
그 횟수만큼 값을 출력해주면 된다.
공간 복잡도 :O(N+K) //극단적으로 0과 999,999로 2개의 데이터가 주어진다고 하면 이런 경우에도 크기가 100만인 배열을 선언해야함.
-> 동일한 값을 여러번 가지는 경우 사용하기 좋다.

result = sorted(array) : array리스트를 정렬한 것을 result에 저장. / array는 그대로.
array.sort() : array 리스트 자체가 정렬됨(원본 수정)

단순 정렬 문제 : 라이브러리
데이터의 범위가 한정 & 더 빠르게 동작해야함 : 계수 정렬

문제 분류
1. 정렬 라이브러리의 사용
2. 정렬 알고리즘의 원리 : 선택, 삽입, 퀵 등 
3. 더 빠른 정렬 : 퀵 정렬 기반X, 계수 정렬 등 다양한 정렬 알고리즘  사용 혹은 기존 알고리즘의 구조적인 개선 




